/*
 *  The scanner definition for COOL.
 */
package lexer;
import java_cup.runtime.Symbol;
import parser.TokenConstants;
import symbolHandling.AbstractSymbol;
import symbolHandling.AbstractTable;
%%
%{
    // Max size of string constants
    static int MAX_STR_CONST = 1025;
    static long MAX_INT=2147483647;//max int size for 32 bit signed (2^31-1)
    static boolean badString=false;//flag for when detected an invalid string
    static int commentDepth=0;//keep track of the depth of nested comments
    StringBuffer builder = new StringBuffer();// For assembling string constants
    private AbstractSymbol filename;
    public void set_filename(String fname) {filename = AbstractTable.stringtable.addString(fname);}
	AbstractSymbol curr_filename() { return filename; }
	public int curr_lineno() { return yyline; }
	static boolean EOFerror=false;//flag that indicates error has been returned at EOF
%}
%init{
    yyline = 1;
%init}
%state BLOCK_COMMENT,STRING
%eofval{
    switch(yy_lexical_state) {
    case YYINITIAL:
	/* nothing special to do in the initial state */
	break;
	case STRING://if in string state, return EOF error
		this.badString=true;
		if(!EOFerror){
			EOFerror=true;
			return new Symbol(TokenConstants.ERROR,"EOF in string constant"); 
		}
	break;
	case BLOCK_COMMENT://if in block_comment state, then there is an unmatech (*
		if(!EOFerror){
			EOFerror=true;
			return new Symbol(TokenConstants.ERROR,"unmatched (*, EOF reached"); 
		}
    }
    return new Symbol(TokenConstants.EOF); 
%eofval}
%class CoolLexer
%cup
%implements java_cup.runtime.Scanner,MyLexer
%line
	/*
	keyword regex defintions
	*/
class=["C""c"]["L""l"]["A""a"]["S""s"]["S""s"]
if=["I""i"]["F""f"]
fi=["F""f"]["I""i"]
then=["T""t"]["H""h"]["E""e"]["N""n"]
inherits=["I""i"]["N""n"]["H""h"]["E""e"]["R""r"]["I""i"]["T""t"]["S""s"]
else=["E""e"]["L""l"]["S""s"]["E""e"]
while=["W""w"]["H""h"]["I""i"]["L""l"]["E""e"]
loop=["L""l"]["O""o"]["O""o"]["P""p"]
pool=["P""p"]["O""o"]["O""o"]["L""l"]
let=["L""l"]["E""e"]["T""t"]
in=["I""i"]["N""n"]
case=["C""c"]["A""a"]["S""s"]["E""e"]
esac=["E""e"]["S""s"]["A""a"]["C""c"]
of=["O""o"]["F""f"]
new=["N""n"]["E""e"]["W""w"]
isvoid=["I""i"]["S""s"]["V""v"]["O""o"]["I""i"]["D""d"]
not=["N""n"]["O""o"]["T""t"]
true=["t"]["R""r"]["U""u"]["E""e"]
false=["f"]["A""a"]["L""l"]["S""s"]["E""e"]
	/*
	basic regex
	*/
digit=[0-9]
integer={digit}+
letterUpper=[A-Z]
letterLower=[a-z]
anyLetter={letterUpper}|{letterLower}
	/*
	identifiers
	*/
typeID={letterUpper}({anyLetter}|{digit}|\_)*
objectID={letterLower}({anyLetter}|{digit}|\_)*
	/*
	comments
	*/
comment=\-\-.*\n
badcomment=\-\-.*$
	/*
	whitespace
	*/
whitespace=[\f\r\t\n\013\040]
	/*
	invalid characters
	*/
notascii=[^\x00-\x7F]
invalidCharacter=[\x00-\x07\x0E-\x1F\x21\x23-\x26\x3F\x5B\x5D-\x5E\x60\x7C\x7F\x27\x3E]
%%

<YYINITIAL> 	"(*" 		{ this.commentDepth=1;yybegin(BLOCK_COMMENT); } //beginning comment
<YYINITIAL> 	{class}		{ return new Symbol(TokenConstants.CLASS); } //class token
<YYINITIAL> 	{if}		{ return new Symbol(TokenConstants.IF); } //if
<YYINITIAL> 	{fi}		{ return new Symbol(TokenConstants.FI); }//fi
<YYINITIAL> 	{then}		{ return new Symbol(TokenConstants.THEN); }//then
<YYINITIAL> 	{inherits}	{ return new Symbol(TokenConstants.INHERITS); }//inherits
<YYINITIAL> 	{else}		{ return new Symbol(TokenConstants.ELSE); }//else
<YYINITIAL> 	{while}		{ return new Symbol(TokenConstants.WHILE); }//while
<YYINITIAL> 	{loop}		{ return new Symbol(TokenConstants.LOOP); }//loop
<YYINITIAL> 	{pool}		{ return new Symbol(TokenConstants.POOL); }//pool
<YYINITIAL> 	{let}		{ return new Symbol(TokenConstants.LET); }//let
<YYINITIAL> 	{in}		{ return new Symbol(TokenConstants.IN); }//in
<YYINITIAL> 	{case}		{ return new Symbol(TokenConstants.CASE); }//case=
<YYINITIAL> 	{esac}		{ return new Symbol(TokenConstants.ESAC); }//esac
<YYINITIAL> 	{of}		{ return new Symbol(TokenConstants.OF); }//of
<YYINITIAL> 	{new}		{ return new Symbol(TokenConstants.NEW); }//new
<YYINITIAL> 	{true}		{ return new Symbol(TokenConstants.BOOL_CONST,true); }//true
<YYINITIAL> 	{false}		{ return new Symbol(TokenConstants.BOOL_CONST,false); }//false
<YYINITIAL> 	"."			{ return new Symbol(TokenConstants.DOT); }//period
<YYINITIAL> 	"@"			{ return new Symbol(TokenConstants.AT); }//at symbol
<YYINITIAL> 	"~"			{ return new Symbol(TokenConstants.NEG); }//negative symbol
<YYINITIAL> 	{isvoid}	{ return new Symbol(TokenConstants.ISVOID); }//isvoid 
<YYINITIAL> 	"*"			{ return new Symbol(TokenConstants.MULT); }// star
<YYINITIAL> 	"/"			{ return new Symbol(TokenConstants.DIV); }// slash
<YYINITIAL> 	"+"			{ return new Symbol(TokenConstants.PLUS); }//plus sign
<YYINITIAL> 	"-"			{ return new Symbol(TokenConstants.MINUS); }//minus sign
<YYINITIAL> 	"<="		{ return new Symbol(TokenConstants.LE); }//less than or equal to
<YYINITIAL> 	"<"			{ return new Symbol(TokenConstants.LT); }//less than
<YYINITIAL> 	"="			{ return new Symbol(TokenConstants.EQ); }//equal
<YYINITIAL> 	{not}		{ return new Symbol(TokenConstants.NOT); }//not keyword
<YYINITIAL> 	"<-"		{ return new Symbol(TokenConstants.ASSIGN); }//assigment operator
<YYINITIAL> 	"{"			{ return new Symbol(TokenConstants.LBRACE); }//left curly brace
<YYINITIAL> 	"}"			{ return new Symbol(TokenConstants.RBRACE); }//right curly brace
<YYINITIAL> 	"("			{ return new Symbol(TokenConstants.LPAREN); }//left parenthesis
<YYINITIAL> 	")"			{ return new Symbol(TokenConstants.RPAREN); }//right parenthesis
<YYINITIAL> 	":"			{ return new Symbol(TokenConstants.COLON); }//colon
<YYINITIAL> 	"=>"		{ return new Symbol(TokenConstants.DARROW); }//double arrow
<YYINITIAL> 	","			{ return new Symbol(TokenConstants.COMMA); }//comma
<YYINITIAL> 	";"			{ return new Symbol(TokenConstants.SEMI); }//semicolon
<YYINITIAL>		"\""		{ this.builder.setLength(0);this.badString=false;yybegin(STRING); }//start of string state
<YYINITIAL> 	"*)" 		{return new Symbol(TokenConstants.ERROR,"Invalid Closing comment *) at line "+yyline); }//end comment error (no valid (* if in yyinitial state)
<YYINITIAL> 	{comment} 	{}//comments -- do nothing
<YYINITIAL> 	{badcomment} 	{return new Symbol(TokenConstants.ERROR,"EOF in comment: line "+yyline);}//bad comments
<YYINITIAL> 	{objectID} 	{ return new Symbol(TokenConstants.OBJECTID,AbstractTable.idtable.addString(yytext())); }//object identifiers -- add to table
<YYINITIAL>		{typeID} 	{ return new Symbol(TokenConstants.TYPEID,AbstractTable.idtable.addString(yytext())); }//type identifiers -- add to table
<YYINITIAL> 	{integer} 	{//integer --- check if too big
						 		long val;
						 		try { val=Long.parseLong(yytext()); } catch(NumberFormatException e){
									return new Symbol(TokenConstants.ERROR,"Integer Constant invalid or too big: line "+yyline+": "+yytext());
						 		}
						 		if ( val> MAX_INT) { return new Symbol(TokenConstants.ERROR,"Integer Constant too Big: line "+yyline+": "+yytext()); }
						        else return new Symbol(TokenConstants.INT_CONST,AbstractTable.inttable.addString(yytext()));
					  		}
					  		
<BLOCK_COMMENT> 	"*)" 	{this.commentDepth--;if(this.commentDepth==0){yybegin(YYINITIAL);}} //if in comment state, closing *) decremetns comment depth. if depth is 0, comment is finished
<BLOCK_COMMENT> 	"(*" 	{this.commentDepth++;}//if see another (*, increase comment depth
<BLOCK_COMMENT>		\n|. 	{ } //catches all other characters in a comment
<STRING> 	"\b" 	{builder.append('\b');}//valid escape character in string
<STRING> 	"\t" 	{builder.append('\t');}//valid escape character in string
<STRING> 	"\n" 	{builder.append('\n');}//valid escape character in string
<STRING> 	\\\n 	{builder.append('\n');}//escaped new line
<STRING> 	"\f" 	{builder.append('\f');}//valid escape character in string

<STRING> 	"\""	{ //if see closing ", return new string token, or error if bad string detected
						yybegin(YYINITIAL); 
						if ( this.badString ){ return new Symbol(TokenConstants.ERROR,"Invalid String Constant at line "+yyline ); }
						else return new Symbol(TokenConstants.STR_CONST,AbstractTable.stringtable.addString(builder.toString())); 
			 		 }
			 		
<STRING> 	\\.		 	{ builder.append(yytext().substring(1,yytext().length()));}// add escaped characters to buffer (without \)
<STRING> 	{notascii} 	{ this.badString=true;}//only ascii characters allowed in string
<STRING> 	\n 			{ this.badString=true;}//no newlines in string
<STRING> 	[^\n\x00] 	{ builder.append(yytext());}//add all other characters to buffer
<YYINITIAL> 	\'.*\'		{ return new Symbol(TokenConstants.ERROR,"Invalid String at line (single quotes) at line "+yyline+": "+yytext() ); } //illegal single quote strings
<YYINITIAL> {whitespace} { }//do nothing with whitespace
<YYINITIAL> 	{invalidCharacter}+   	{ return new Symbol(TokenConstants.ERROR,"Invalid character(s): line "+yyline+": "+yytext());}//strings of invalid characters
<YYINITIAL> 	.   	{ return new Symbol(TokenConstants.ERROR,"Invalid character: line "+yyline+": "+yytext());}//other possible non ascii invalid characters
						
